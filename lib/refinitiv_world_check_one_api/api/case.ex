# NOTE: This file is auto generated by OpenAPI Generator 6.3.0 (https://openapi-generator.tech).
# Do not edit this file manually.

defmodule RefinitivWorldCheckOneAPI.Api.Case do
  @moduledoc """
  API calls for all endpoints tagged `Case`.
  """

  alias RefinitivWorldCheckOneAPI.Connection
  import RefinitivWorldCheckOneAPI.RequestBuilder

  @doc """
  Archive a Case.
  Archive the Case identified by the given caseSystemId. This will put the case into a state from which it can be either unarchived or deleted. The user must be active and have the archive permission. 

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details).
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format.
  - `case_system_id` (String.t): System generated ID for the Case
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, nil}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec archive_case(Tesla.Env.client, String.t, String.t, String.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:error, Tesla.Env.t}
  def archive_case(connection, authorization, date, case_system_id, _opts \\ []) do
    request =
      %{}
      |> method(:put)
      |> url("/cases/#{case_system_id}/archive")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> ensure_body()
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {204, false},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  Bulk Update Archive States
  Bulk Update Archive States of cases identified by the given `caseSystemIds`. The arhive states are updated  according to the value specified in the `\"archive\"` field: if set to `true` then all the cases will be updated  with the \"archive\" state, otherwise, the \"unarchived\" state will be used.  In response, the user receives a summary (`\"statuses\"`) of the archiving operation for each case.  *Example HTTP response* below, shows the following summary:    1. The first case with `\"caseSystemId1\"` has been archived successfully.   2. The second case with `\"caseSystemId2\"` has been archived successfully.   3. The third case with `\"caseSystemId3\"` has not been archived because it does not meet the validation criteria;   `\"error\"` and `\"cause\"` fields contain detailed information on the error.  The user must be active and have the archive permission. 

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details)
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format
  - `content_type` (String.t): The media type of the request (e.g., 'application/json')
  - `content_length` (integer()): The length of the request body in octets (8-bit bytes)
  - `case_bulk_archive_request` (CaseBulkArchiveRequest): A request on Bulk Update Archive States
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, RefinitivWorldCheckOneAPI.Model.CaseBulkResponse.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec archive_cases(Tesla.Env.client, String.t, String.t, String.t, integer(), RefinitivWorldCheckOneAPI.Model.CaseBulkArchiveRequest.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:ok, RefinitivWorldCheckOneAPI.Model.CaseBulkResponse.t} | {:error, Tesla.Env.t}
  def archive_cases(connection, authorization, date, content_type, content_length, case_bulk_archive_request, _opts \\ []) do
    request =
      %{}
      |> method(:post)
      |> url("/cases/bulk/archive")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> add_param(:headers, :"Content-Type", content_type)
      |> add_param(:headers, :"Content-Length", content_length)
      |> add_param(:body, :body, case_bulk_archive_request)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, %RefinitivWorldCheckOneAPI.Model.CaseBulkResponse{}},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  Assign the Case to a User.
  Assign the Case to a User. '/users' endpoint provides the active users that a Case can be assigned to. 

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details)
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format
  - `content_type` (String.t): The media type of the request (e.g., 'application/json')
  - `content_length` (integer()): The length of the request body in octets (8-bit bytes)
  - `case_system_id` (String.t): System generated ID for the Case.
  - `assignee` (Assignee): User to whom the case will be assigned.
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, nil}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec assign_case(Tesla.Env.client, String.t, String.t, String.t, integer(), String.t, RefinitivWorldCheckOneAPI.Model.Assignee.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:error, Tesla.Env.t}
  def assign_case(connection, authorization, date, content_type, content_length, case_system_id, assignee, _opts \\ []) do
    request =
      %{}
      |> method(:put)
      |> url("/cases/#{case_system_id}/assignee")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> add_param(:headers, :"Content-Type", content_type)
      |> add_param(:headers, :"Content-Length", content_length)
      |> add_param(:body, :body, assignee)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {204, false},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  Bulk Update Case Assignments
  Bulk Update Case Assignments, where `Case`s are identified by the given `caseSystemIds` and assignee `User`  is identified by the given `userId` (in case of assigning action). The case assignements are updated according  to the value specified in the `\"userId\"` field: if set to `null` or is absent then the bulk unassigning action  happens, otherwise, the bulk assigning to the `User` identified by the given `userId` action  is performed.  In response, the user receives a summary (`\"statuses\"`) of the assigning/unassigning operation for each case.  *Example HTTP response* below, shows the following summary:    1. The first case with `\"caseSystemId1\"` has been assigned successfully.   2. The second case with `\"caseSystemId2\"` has been assigned successfully.   3. The third case with `\"caseSystemId3\"` has not been assigned because it does not meet the validation criteria;   `\"error\"` and `\"cause\"` fields contain detailed information on the error.  The user must be active and have the archive permission. 

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details)
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format
  - `content_type` (String.t): The media type of the request (e.g., 'application/json')
  - `content_length` (integer()): The length of the request body in octets (8-bit bytes)
  - `case_bulk_assign_request` (CaseBulkAssignRequest): A request on Bulk Update Case Assignments
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, RefinitivWorldCheckOneAPI.Model.CaseBulkResponse.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec assign_cases(Tesla.Env.client, String.t, String.t, String.t, integer(), RefinitivWorldCheckOneAPI.Model.CaseBulkAssignRequest.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:ok, RefinitivWorldCheckOneAPI.Model.CaseBulkResponse.t} | {:error, Tesla.Env.t}
  def assign_cases(connection, authorization, date, content_type, content_length, case_bulk_assign_request, _opts \\ []) do
    request =
      %{}
      |> method(:post)
      |> url("/cases/bulk/assign")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> add_param(:headers, :"Content-Type", content_type)
      |> add_param(:headers, :"Content-Length", content_length)
      |> add_param(:body, :body, case_bulk_assign_request)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, %RefinitivWorldCheckOneAPI.Model.CaseBulkResponse{}},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  Check if a given caseId is available for use
  caseIds must be unique within each Client. If any Group under a Client has a Case with a particular caseId, that caseId cannot be reused on another Case within the same Client. This endpoint allows the user to check if a given caseId is available to use when creating or updating a Case. 

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details)
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format
  - `case_id` (String.t): Id to check if it is available to use as a caseId
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, nil}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec check_case_identifier_availability(Tesla.Env.client, String.t, String.t, String.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:error, Tesla.Env.t}
  def check_case_identifier_availability(connection, authorization, date, case_id, _opts \\ []) do
    request =
      %{}
      |> method(:head)
      |> url("/caseIdentifiers")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> add_param(:query, :caseId, case_id)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, false},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {404, false},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  Delete a Case
  Delete a Case identified by the given caseSystemId. The case must be first archived in order to delete it. The user must be active and have delete permissions. The client must have delete functionality enabled. 

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details)
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format
  - `case_system_id` (String.t): System generated ID for the Case
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, nil}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec delete_case(Tesla.Env.client, String.t, String.t, String.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:error, Tesla.Env.t}
  def delete_case(connection, authorization, date, case_system_id, _opts \\ []) do
    request =
      %{}
      |> method(:delete)
      |> url("/cases/#{case_system_id}")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {204, false},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  Bulk Delete Cases
  Bulk Delete Cases identified by the given `caseSystemIds`. The cases must be first archived in order to delete them. The user must be active and have delete permissions. The client must have delete functionality enabled.  In response, the user receives a summary (`\"statuses\"`) of the archiving operation for each case.  *Example HTTP response* below, shows the following summary:    1. The first case with `\"caseSystemId1\"` has been deleted successfully.   2. The second case with `\"caseSystemId2\"` has been deleted successfully.   3. The third case with `\"caseSystemId3\"` has not been deleted because it does not meet the validation criteria;   `\"error\"` and `\"cause\"` fields contain detailed information on the error. 

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details)
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format
  - `content_type` (String.t): The media type of the request (e.g., 'application/json')
  - `content_length` (integer()): The length of the request body in octets (8-bit bytes)
  - `case_bulk_delete_request` (CaseBulkDeleteRequest): A request on Bulk Delete Cases
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, RefinitivWorldCheckOneAPI.Model.CaseBulkResponse.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec delete_cases(Tesla.Env.client, String.t, String.t, String.t, integer(), RefinitivWorldCheckOneAPI.Model.CaseBulkDeleteRequest.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:ok, RefinitivWorldCheckOneAPI.Model.CaseBulkResponse.t} | {:error, Tesla.Env.t}
  def delete_cases(connection, authorization, date, content_type, content_length, case_bulk_delete_request, _opts \\ []) do
    request =
      %{}
      |> method(:post)
      |> url("/cases/bulk/delete")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> add_param(:headers, :"Content-Type", content_type)
      |> add_param(:headers, :"Content-Length", content_length)
      |> add_param(:body, :body, case_bulk_delete_request)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, %RefinitivWorldCheckOneAPI.Model.CaseBulkResponse{}},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  Disable OGS for a Case.
  Disable Ongoing Screening for the Case identified by the given caseSystemId. In order to disable Ongoing Screening for multiple or specific provider type fill out an optional request body with provider types for which to disable Ongoing Screening. If no request body provided Ongoing Screening request will be performed for WATCHLIST provider type. 

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details).
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format.
  - `content_type` (String.t): The media type of the request (e.g., 'application/json').
  - `content_length` (integer()): The length of the request body in octets (8-bit bytes).
  - `case_system_id` (String.t): System generated ID for the Case.
  - `opts` (keyword): Optional parameters
    - `:body` (OngoingScreeningRequest): Request containing details to disable Ongoing Screening for case.

  ### Returns

  - `{:ok, nil}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec disable_ongoing_screening(Tesla.Env.client, String.t, String.t, String.t, integer(), String.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:error, Tesla.Env.t}
  def disable_ongoing_screening(connection, authorization, date, content_type, content_length, case_system_id, opts \\ []) do
    optional_params = %{
      :body => :body
    }

    request =
      %{}
      |> method(:delete)
      |> url("/cases/#{case_system_id}/ongoingScreening")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> add_param(:headers, :"Content-Type", content_type)
      |> add_param(:headers, :"Content-Length", content_length)
      |> add_optional_params(optional_params, opts)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {204, false},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  Enable OGS for a Case.
  Enable Ongoing Screening for the Case identified by the given caseSystemId. This will schedule the Case to be re-screened periodically by the system. In order to enable Ongoing Screening for multiple or specific provider type fill out an optional request body with provider types for which to enable Ongoing Screening. If no request body provided Ongoing Screening request will be performed for WATCHLIST provider type. 

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details).
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format.
  - `content_type` (String.t): The media type of the request (e.g., 'application/json').
  - `content_length` (integer()): The length of the request body in octets (8-bit bytes).
  - `case_system_id` (String.t): System generated ID for the Case.
  - `opts` (keyword): Optional parameters
    - `:body` (OngoingScreeningRequest): Request containing details to enable Ongoing Screening for case.

  ### Returns

  - `{:ok, nil}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec enable_ongoing_screening(Tesla.Env.client, String.t, String.t, String.t, integer(), String.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:error, Tesla.Env.t}
  def enable_ongoing_screening(connection, authorization, date, content_type, content_length, case_system_id, opts \\ []) do
    optional_params = %{
      :body => :body
    }

    request =
      %{}
      |> method(:put)
      |> url("/cases/#{case_system_id}/ongoingScreening")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> add_param(:headers, :"Content-Type", content_type)
      |> add_param(:headers, :"Content-Length", content_length)
      |> add_optional_params(optional_params, opts)
      |> ensure_body()
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {204, false},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  Fetch Full Case Details
  Returns full details of the Case identified by the given `caseSystemId`

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details)
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format
  - `case_system_id` (String.t): System generated ID for the Case
  - `opts` (keyword): Optional parameters
    - `:aggregatedSummary` (boolean()): Flag to enable aggregated summary for case

  ### Returns

  - `{:ok, RefinitivWorldCheckOneAPI.Model.Case.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec get_case(Tesla.Env.client, String.t, String.t, String.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:ok, RefinitivWorldCheckOneAPI.Model.Case.t} | {:error, Tesla.Env.t}
  def get_case(connection, authorization, date, case_system_id, opts \\ []) do
    optional_params = %{
      :aggregatedSummary => :query
    }

    request =
      %{}
      |> method(:get)
      |> url("/cases/#{case_system_id}")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> add_optional_params(optional_params, opts)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, %RefinitivWorldCheckOneAPI.Model.Case{}},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  Get a filtered list of AuditEvents for a Case by its caseSystemId
  Return all audit events related to cases visible to the current user. To get all audit events initial request with no payload should be provided. Also, caller may filter and sort the response by:  **eventDate**: The time when the Audit Event was created (ISO 8601 format excluding Week and Ordinal dates)         e.g. eventDate>=2010-07-28T22:25:51Z;eventDate<2015-07-28T22:25:51Z  Note: When the audit is requested without any date range in the query, it returns the audit data **for the last 168 hours by default**.  **actionType**: Signifies the event links to a Case object.           Please refer to ``ActionType`` object for detailed description.         e.g. actionType=='ASSIGN_CASE'             actionType=in=('ASSIGN_CASE', 'NEW_MATCH')   **actionedByUserId**: Identifier of the User who created this audit event.            Please refer to ``AuditEvent/properties/actionedByUserId`` for detailed description.         e.g. actionedByUserId==663b4481-5b45-40a4-8b76-54ef805beea5   **The above criteria can also be combined**         e.g. eventDate>=20120915T155300;eventDate<=2015-07-28T22:25:51Z;actionType=='NEW_MATCH'             actionedByUserId==663b4481-5b45-40a4-8b76-54ef805beea5;eventDate>=2010-07-28T22:25:51Z  **Please note that the above examples are only for the ``query`` part of the Filter** 

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details)
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format
  - `content_type` (String.t): The media type of the request (e.g., 'application/json')
  - `content_length` (integer()): The length of the request body in octets (8-bit bytes)
  - `case_system_id` (String.t): System generated ID for the Case
  - `opts` (keyword): Optional parameters
    - `:body` (Filter): Filter the AuditEvents in the response

  ### Returns

  - `{:ok, RefinitivWorldCheckOneAPI.Model.AuditSearchResponse.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec get_case_audit_events_by_case_system_id(Tesla.Env.client, String.t, String.t, String.t, integer(), String.t, keyword()) :: {:ok, nil} | {:ok, RefinitivWorldCheckOneAPI.Model.AuditSearchResponse.t} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:error, Tesla.Env.t}
  def get_case_audit_events_by_case_system_id(connection, authorization, date, content_type, content_length, case_system_id, opts \\ []) do
    optional_params = %{
      :body => :body
    }

    request =
      %{}
      |> method(:post)
      |> url("/cases/#{case_system_id}/auditEvents")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> add_param(:headers, :"Content-Type", content_type)
      |> add_param(:headers, :"Content-Length", content_length)
      |> add_optional_params(optional_params, opts)
      |> ensure_body()
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, %RefinitivWorldCheckOneAPI.Model.AuditSearchResponse{}},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  Return the CaseReference (caseId, caseSystemId) for a caseId
  Returns the CaseReference containing the caseId and caseSystemId pair for an existing Case with the given caseId. This is useful if only the caseId is known but caseSystemId is required by other endpoints such as 'GET /cases/{caseSystemId}'. 

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details)
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format
  - `case_id` (String.t): Case ID provided by the client or else generated by the system for the client
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, RefinitivWorldCheckOneAPI.Model.CaseReference.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec get_case_reference(Tesla.Env.client, String.t, String.t, String.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:ok, RefinitivWorldCheckOneAPI.Model.CaseReference.t} | {:error, Tesla.Env.t}
  def get_case_reference(connection, authorization, date, case_id, _opts \\ []) do
    request =
      %{}
      |> method(:get)
      |> url("/caseReferences")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> add_param(:query, :caseId, case_id)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, %RefinitivWorldCheckOneAPI.Model.CaseReference{}},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  Get ongoing screening updates.
  Get ongoing screening updates for all `Case` objects that are visible to the current user and are flagged for ongoing screening.  Filter and sort the ongoing screening updates in the response by:    **updateDate**: The date and time of this ongoing screening update in ISO 8601 format (excluding Week and   Ordinal dates).  Required.    **providerType**: Ongoing screening provider type to query for results. Optional.    e.g. Filter body that specifies the page size to be `50` and queries the first page of ongoing screening updates   for WATCHLIST and MEDIA_CHECK provider types occurred since `2016-07-26T00:00:00Z` sorted by `updateDate` in `DESCENDING` order:      {       \"query\": \"updateDate>='2016-07-26T00:00:00Z', providerType==WATCHLIST, providerType==MEDIA_CHECK\",       \"sort\": [         {           \"columnName\": \"updateDate\",           \"order\": \"DESCENDING\"         }       ],       \"pagination\": {         \"currentPage\": 1,         \"itemsPerPage\": 50       }     } 

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details)
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format
  - `content_type` (String.t): The media type of the request (e.g., 'application/json')
  - `content_length` (integer()): The length of the request body in octets (8-bit bytes)
  - `filter` (Filter): Filter and sort the ongoing screening updates in the response.
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, RefinitivWorldCheckOneAPI.Model.OngoingScreeningUpdateSearchResponse.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec get_ongoing_screening_updates(Tesla.Env.client, String.t, String.t, String.t, integer(), RefinitivWorldCheckOneAPI.Model.Filter.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:ok, RefinitivWorldCheckOneAPI.Model.OngoingScreeningUpdateSearchResponse.t} | {:error, Tesla.Env.t}
  def get_ongoing_screening_updates(connection, authorization, date, content_type, content_length, filter, _opts \\ []) do
    request =
      %{}
      |> method(:post)
      |> url("/cases/ongoingScreeningUpdates")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> add_param(:headers, :"Content-Type", content_type)
      |> add_param(:headers, :"Content-Length", content_length)
      |> add_param(:body, :body, filter)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, %RefinitivWorldCheckOneAPI.Model.OngoingScreeningUpdateSearchResponse{}},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  Get collection of Results for a Case by its caseSystemId
  Return a collection of Results for the Case identified by the given caseSystemId. The response may contain Special Interest Categories (SIC) records that depends on the user subscription type. This helps in SIC risk analysis: If a user has subscription type is Premium or Premium Plus, the keywords for SIC subcategories provided in the \"sources\" field and full value of SIC keywords code in the \"categories\" field. If a user has a Standard subscription type then the \"categories\" field will not contain SIC keywords. The above behavior is the same for Zero Footprint Screening (ZFS).  The example response body includes SIC with Premium or Premium Plus user subscription:  ```     {       \"sources\":[         \"b_trwc_M:1TQ\",         \"b_trwc_4\"       ],       \"categories\":[         \"Special Interest Categories\",         \"Other Bodies\"       ]     } ``` 

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details)
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format
  - `case_system_id` (String.t): System generated ID for a Case
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, [%Result{}, ...]}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec get_results(Tesla.Env.client, String.t, String.t, String.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Result.t)} | {:error, Tesla.Env.t}
  def get_results(connection, authorization, date, case_system_id, _opts \\ []) do
    request =
      %{}
      |> method(:get)
      |> url("/cases/#{case_system_id}/results")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, [%RefinitivWorldCheckOneAPI.Model.Result{}]},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  Bulk Update Case Links
  Bulk Update Case Links for `Case`s with provided `caseSystemIds` and `relationshipTypes` specified in  `relationshipType` field. The case links are updated according to the value specified in the \"link\" field:  if set to `true` then the link bulk action happens, otherwise, the unlinking is performed.  In response, the user receives a summary (`\"statuses\"`) of the Link/Unlink operation for each case.  *Example HTTP response* below, shows the following summary:    1. The first case with `\"caseSystemId1\"` was linked/unlinked successfully.   2. The second case with `\"caseSystemId2\"` was linked/unlinked successfully.   3. Link/Unlink operation can not be performed for the third case with `\"caseSystemId3\"` because it does not meet the validation criteria;   `\"error\"` and `\"cause\"` fields contain detailed information on the error. 

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details)
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format
  - `content_type` (String.t): The media type of the request (e.g., 'application/json')
  - `content_length` (integer()): The length of the request body in octets (8-bit bytes)
  - `case_bulk_link_request_collection` (CaseBulkLinkRequestCollection): A request on Bulk Update Case Links
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, RefinitivWorldCheckOneAPI.Model.CaseBulkResponse.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec link_cases(Tesla.Env.client, String.t, String.t, String.t, integer(), RefinitivWorldCheckOneAPI.Model.CaseBulkLinkRequestCollection.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:ok, RefinitivWorldCheckOneAPI.Model.CaseBulkResponse.t} | {:error, Tesla.Env.t}
  def link_cases(connection, authorization, date, content_type, content_length, case_bulk_link_request_collection, _opts \\ []) do
    request =
      %{}
      |> method(:post)
      |> url("/cases/bulk/link")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> add_param(:headers, :"Content-Type", content_type)
      |> add_param(:headers, :"Content-Length", content_length)
      |> add_param(:body, :body, case_bulk_link_request_collection)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, %RefinitivWorldCheckOneAPI.Model.CaseBulkResponse{}},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  Partial update an existing Case by its caseSystemId
  Updates an existing Case identified by the given caseSystemId. When the case is updated, only updated field(s) for the case are required to be sent. If non-empty fields are not sent they will be left untouched. Case screening results related to the value provided in Screen query parameter. Calling the endpoint without any change in the existing case payload, but retained query parameter screen=SYNC, works as synchronous re-screening.  **Note:** The maximum number of World-Check screenings (including initial, rescreening, and ZFP ones)           that a client can perform in an hour is limited.  **Info about available secondary fields can be found [here](#tag/groups/operation/getCaseTemplateForGroup).** 

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details)
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format
  - `content_type` (String.t): The media type of the request (e.g., 'application/json')
  - `content_length` (integer()): The length of the request body in octets (8-bit bytes)
  - `case_system_id` (String.t): System generated ID for the Case
  - `update_case` (UpdateCase): Update Case
  - `opts` (keyword): Optional parameters
    - `:screen` (String.t): Screen mode

  ### Returns

  - `{:ok, RefinitivWorldCheckOneAPI.Model.ScreeningResultCollection.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec partial_update_case(Tesla.Env.client, String.t, String.t, String.t, integer(), String.t, RefinitivWorldCheckOneAPI.Model.UpdateCase.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:ok, RefinitivWorldCheckOneAPI.Model.ScreeningResultCollection.t} | {:error, Tesla.Env.t}
  def partial_update_case(connection, authorization, date, content_type, content_length, case_system_id, update_case, opts \\ []) do
    optional_params = %{
      :screen => :query
    }

    request =
      %{}
      |> method(:patch)
      |> url("/cases/#{case_system_id}")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> add_param(:headers, :"Content-Type", content_type)
      |> add_param(:headers, :"Content-Length", content_length)
      |> add_param(:body, :body, update_case)
      |> add_optional_params(optional_params, opts)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, %RefinitivWorldCheckOneAPI.Model.ScreeningResultCollection{}},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {403, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  Resolves a list of results.
  Resolves a list of results for the Case identified by the given caseSystemId. The endpoint for the resolution toolkit '/groups/{groupId}/resolutionToolkit' provides the resolution rules to be applied when resolving results of any [Case](#Case) within a specific [Group](#Group).  Any resultIds which relate to records that have been removed from World-Check One can only be resolved as FALSE. 

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details).
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format.
  - `content_type` (String.t): The media type of the request (e.g., 'application/json').
  - `content_length` (integer()): The length of the request body in octets (8-bit bytes).
  - `case_system_id` (String.t): System generated ID for the Case.
  - `results_resolution_action` (ResultsResolutionAction): Represents the request details required for resolving Results.  **Note:** Fields 'reasonId' and 'resolutionRemark' are required **ONLY** if they are specified accordingly in the configuration settings. 
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, nil}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec resolve_results(Tesla.Env.client, String.t, String.t, String.t, integer(), String.t, RefinitivWorldCheckOneAPI.Model.ResultsResolutionAction.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:error, Tesla.Env.t}
  def resolve_results(connection, authorization, date, content_type, content_length, case_system_id, results_resolution_action, _opts \\ []) do
    request =
      %{}
      |> method(:put)
      |> url("/cases/#{case_system_id}/results/resolution")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> add_param(:headers, :"Content-Type", content_type)
      |> add_param(:headers, :"Content-Length", content_length)
      |> add_param(:body, :body, results_resolution_action)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {204, false},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  User activity monitoring. Initial request.
  Return a collection of Cases that were modified by users in particular date range. Endpoint allow to initiate search and retrieve the first page of result set. The query supports next field to specify searching criteria:  'modificationDate' - Time when the case has been modified by the user;  'assignedUserId' - Identifier of the User cases are assigned to;  'groupId' - Identifier of the Group that owns the case;  'creatorUserId' - Identifier of the case author;  'modifierUserId' - Identifier of the recent changes author;  'creationDate' - Time when the case has been created.  To retrieve the next set of results please use '/cases/summaries/cursor' endpoint. 

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details)
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format
  - `content_type` (String.t): The media type of the request (e.g., 'application/json')
  - `content_length` (integer()): The length of the request body in octets (8-bit bytes)
  - `filter` (CaseSummaryFilter): The \"query\" is a FIQL expression which allows specifying comparison expression on case fields and it also allows specifying boolean operators AND/OR. The \"sort\" allows specifying items order in the response. The \"cursorOptions\" allows specifying count of items in the first response.
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, RefinitivWorldCheckOneAPI.Model.CaseSearchResultResponse.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec retrieve_case_summaries(Tesla.Env.client, String.t, String.t, String.t, integer(), RefinitivWorldCheckOneAPI.Model.CaseSummaryFilter.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:ok, RefinitivWorldCheckOneAPI.Model.CaseSearchResultResponse.t} | {:error, Tesla.Env.t}
  def retrieve_case_summaries(connection, authorization, date, content_type, content_length, filter, _opts \\ []) do
    request =
      %{}
      |> method(:post)
      |> url("/cases/summaries")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> add_param(:headers, :"Content-Type", content_type)
      |> add_param(:headers, :"Content-Length", content_length)
      |> add_param(:body, :body, filter)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, %RefinitivWorldCheckOneAPI.Model.CaseSearchResultResponse{}},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  Add a review remark to the specified result IDs for the given case
  Add a review remark to the specified result IDs for the given case.

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details)
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format
  - `content_type` (String.t): The media type of the request (e.g., 'application/json')
  - `content_length` (integer()): The length of the request body in octets (8-bit bytes)
  - `case_system_id` (String.t): System generated ID for the Case
  - `results_review` (ResultsReview): Object representing the IDs to be reviewed, and the review remark
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, nil}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec review_results(Tesla.Env.client, String.t, String.t, String.t, integer(), String.t, RefinitivWorldCheckOneAPI.Model.ResultsReview.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:error, Tesla.Env.t}
  def review_results(connection, authorization, date, content_type, content_length, case_system_id, results_review, _opts \\ []) do
    request =
      %{}
      |> method(:put)
      |> url("/cases/#{case_system_id}/results/review")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> add_param(:headers, :"Content-Type", content_type)
      |> add_param(:headers, :"Content-Length", content_length)
      |> add_param(:body, :body, results_review)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {204, false},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  Save and screen multiple cases.
  Save and screen multiple cases for the given group Id. Caller may include multiple cases with up to 50 entities in a single request (see *Example HTTP request* below). In response, the caller receives a summary of the creation operation for each case.  *Example HTTP response* below, shows the following summary:    1. The first case has been created successfully.   2. The second case has not been created successfully because it does not meet the validation criteria;    \"errors\" and \"cause\" fields contain detailed information.  **Example HTTP response**  ```   [       {           \"name\": \"Name 1\",           \"caseId\": \"Case ID 1\",           \"caseSystemId\": \"Case System ID 1\",           \"nameTransposition\": true,           \"caseScreeningState\": {               \"WATCHLIST\": \"INITIAL\"           }       },       {           \"name\": \"Name 2\",           \"caseId\": \"Case ID 2\",           \"errors\": [               {                   \"error\": \"CASE_ID_EXISTS\",                   \"cause\": \"Case IDs must be unique within the same client and request.\"               }           ]       }   ] ```  **Note:** The maximum number of World-Check screenings (including initial, rescreening, and ZFP ones)           that a client can perform in an hour is limited. 

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details)
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format
  - `content_type` (String.t): The media type of the request (e.g., 'application/json')
  - `content_length` (integer()): The length of the request body in octets (8-bit bytes)
  - `case_details_collection` (CaseDetailsCollection): Container of cases that is used in scope of creation operation.
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, [%CaseReferenceDetails{}, ...]}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec save_and_screen_cases(Tesla.Env.client, String.t, String.t, String.t, integer(), RefinitivWorldCheckOneAPI.Model.CaseDetailsCollection.t, keyword()) :: {:ok, list(RefinitivWorldCheckOneAPI.Model.CaseReferenceDetails.t)} | {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:error, Tesla.Env.t}
  def save_and_screen_cases(connection, authorization, date, content_type, content_length, case_details_collection, _opts \\ []) do
    request =
      %{}
      |> method(:post)
      |> url("/cases/saveAndScreen")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> add_param(:headers, :"Content-Type", content_type)
      |> add_param(:headers, :"Content-Length", content_length)
      |> add_param(:body, :body, case_details_collection)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, [%RefinitivWorldCheckOneAPI.Model.CaseReferenceDetails{}]},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {403, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  Create a new case
  Creates a new Case for asynchronous screening. Synchronous screening on the dedicated ZFS gateway host via `/cases/screeningRequest` should be used instead of this for Zero Footprint Screening (ZFS).  **Info about available secondary fields can be found [here](#tag/groups/operation/getCaseTemplateForGroup).** 

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details)
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format
  - `content_type` (String.t): The media type of the request (e.g., 'application/json')
  - `content_length` (integer()): The length of the request body in octets (8-bit bytes)
  - `new_case` (NewCase): Case to be created
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, RefinitivWorldCheckOneAPI.Model.Case.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec save_case(Tesla.Env.client, String.t, String.t, String.t, integer(), RefinitivWorldCheckOneAPI.Model.NewCase.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:ok, RefinitivWorldCheckOneAPI.Model.Case.t} | {:error, Tesla.Env.t}
  def save_case(connection, authorization, date, content_type, content_length, new_case, _opts \\ []) do
    request =
      %{}
      |> method(:post)
      |> url("/cases")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> add_param(:headers, :"Content-Type", content_type)
      |> add_param(:headers, :"Content-Length", content_length)
      |> add_param(:body, :body, new_case)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {201, %RefinitivWorldCheckOneAPI.Model.Case{}},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {403, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  Perform synchronous screening for a new case
  Perform synchronous screening for a new case.  This endpoint can perform a synchronous screening for a set of valid case details and, if provided, set the ongoing screening (OGS) state for the given provider types. The supported provider types for setting the OGS state are WATCHLIST and MEDIA_CHECK. They both can be set to either INITIAL (OGS disabled) or ONGOING (OGS enabled) state. You cannot set the OGS state when using Zero Footprint Screening (ZFS) groups.  The returned result collection contains the regular case result details plus identity documents and important events. ZFS is enabled by specifying a ZFS group id in the body and is available for dedicated Zero-footprint API customers or Regular WC1 API customers using ZFS-specific groups.  The response may contain Special Interest Categories (SIC) records that depends on the user subscription type. This helps in SIC risk analysis:    - if a user has subscription type is Premium or Premium Plus, the keywords for SIC subcategories provided   in the \"sources\" field and full value of SIC keywords code in the \"categories\" field;    -  if a user has a Standard subscription type then the \"categories\" field will not contain SIC keywords;    -  the above behavior is the same for ZFS.  The example response body includes SIC with Premium or Premium Plus user subscription:  ```     {       \"sources\":[         \"b_trwc_M:1TQ\",         \"b_trwc_4\"       ],       \"categories\":[         \"Special Interest Categories\",         \"Other Bodies\"       ]     } ```  **Note:** The maximum number of World-Check screenings (including initial, rescreening, and ZFP ones)           that a client can perform in an hour is limited.  **Info about available secondary fields can be found [here](#tag/groups/operation/getCaseTemplateForGroup).** 

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details)
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format
  - `content_type` (String.t): The media type of the request (e.g., 'application/json')
  - `content_length` (integer()): The length of the request body in octets (8-bit bytes)
  - `screening_request` (ScreeningRequest): Screening Request
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, RefinitivWorldCheckOneAPI.Model.ScreeningResultCollection.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec screen(Tesla.Env.client, String.t, String.t, String.t, integer(), RefinitivWorldCheckOneAPI.Model.ScreeningRequest.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:ok, RefinitivWorldCheckOneAPI.Model.ScreeningResultCollection.t} | {:error, Tesla.Env.t}
  def screen(connection, authorization, date, content_type, content_length, screening_request, _opts \\ []) do
    request =
      %{}
      |> method(:post)
      |> url("/cases/screeningRequest")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> add_param(:headers, :"Content-Type", content_type)
      |> add_param(:headers, :"Content-Length", content_length)
      |> add_param(:body, :body, screening_request)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, %RefinitivWorldCheckOneAPI.Model.ScreeningResultCollection{}},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {403, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  Request full or delta screening for an existing Case.
  Make a request for screening of the Case identified by the given caseSystemId.  Screening could be synchronous or asynchronous operation. The type of Screening could be full or delta.  In the case of asynchronous Screening result will return immediately. As a result of this call,  the screening request will be queued to be processed. When this request has been processed, there will be a new  `SCREENED_CASE` audit event that can be queried via `/cases/{caseSystemId}/auditEvents` and then the results  can be retrieved via `/cases/{caseSystemId}/results`.  In the case of a synchronous screening as a result of the call will be returned result collection contains  the regular case result details plus identity documents and important events.  Delta Screening performs Screening from the time of the last screening date and shows new results that appeared  after the last screening.  **Note:** The maximum number of World-Check screenings (including initial, rescreening, and ZFP ones)           that a client can perform in an hour is limited. 

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details).
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format.
  - `case_system_id` (String.t): System generated ID for the Case.
  - `opts` (keyword): Optional parameters
    - `:"Content-Type"` (String.t): The media type of the request (e.g., 'application/json').
    - `:"Content-Length"` (integer()): The length of the request body in octets (8-bit bytes).
    - `:body` (CaseScreeningRequest): Case Screening Request.

  ### Returns

  - `{:ok, RefinitivWorldCheckOneAPI.Model.CaseScreeningResultCollection.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec screen_case(Tesla.Env.client, String.t, String.t, String.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:ok, RefinitivWorldCheckOneAPI.Model.CaseScreeningResultCollection.t} | {:error, Tesla.Env.t}
  def screen_case(connection, authorization, date, case_system_id, opts \\ []) do
    optional_params = %{
      :"Content-Type" => :headers,
      :"Content-Length" => :headers,
      :body => :body
    }

    request =
      %{}
      |> method(:post)
      |> url("/cases/#{case_system_id}/screeningRequest")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> add_optional_params(optional_params, opts)
      |> ensure_body()
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, %RefinitivWorldCheckOneAPI.Model.CaseScreeningResultCollection{}},
      {201, false},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {403, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  Retrieve case screening status and aggregated result for multiple cases.
  Retrieve case screening statuses and aggregated results. Caller may include multiple cases with up to 50 entities in a single request (see *Example HTTP request* below). In response, the caller receives a status and aggregated screening results for each case.  **Example HTTP response**  ```   Response example returned for request not containing \"providerTypes\" field.   [       {           \"caseSystemId\": \"Case System ID 1\",           \"screeningStatus\": \"SCREENED\",           \"requestFromScreenedDate\": \"2020-10-24T11:40:21.517Z\",           \"lastScreenedDate\": \"2019-12-16T14:44:15.582Z\",           \"providerSummaries\": {               \"WATCHLIST\": {                   \"totalMatches\": 38,                   \"reviewRequired\": 0,                   \"unresolved\": 35               }           }       },       {           \"caseSystemId\": \"Case System ID 2\",           \"screeningStatus\": \"NOT_SCREENED\",           \"requestFromScreenedDate\": \"2020-10-24T11:40:21.517Z\",           \"providerSummaries\": {               \"WATCHLIST\": {                   \"totalMatches\": 0,                   \"reviewRequired\": 0,                   \"unresolved\": 0               },               \"PASSPORT_CHECK\": {                   \"isReviewRequired\": false               }           }       },       {           \"caseSystemId\": \"Case System ID 3\",           \"screeningStatus\": \"SCREENED\",           \"requestFromScreenedDate\": \"2019-10-24T11:40:21.517Z\",           \"lastScreenedDate\": \"2019-12-20T08:25:32.146Z\",           \"providerSummaries\": {               \"WATCHLIST\": {                   \"totalMatches\": 625,                   \"reviewRequired\": 0,                   \"unresolved\": 618               }           }       }   ]    Response example returned for request containing \"providerTypes\" field.   [       {           \"caseSystemId\": \"Case System ID 1\",           \"requestFromScreenedDate\": \"2020-10-24T11:40:21.517Z\",           \"lastScreenedDate\": \"2019-12-16T14:44:15.582Z\",           \"providerSummaries\": {               \"WATCHLIST\": {                   \"status\": \"SCREENED\",                   \"totalMatches\": 38,                   \"reviewRequired\": 0,                   \"unresolved\": 35               }           }       },       {           \"caseSystemId\": \"Case System ID 2\",           \"requestFromScreenedDate\": \"2020-10-24T11:40:21.517Z\",           \"providerSummaries\": {               \"WATCHLIST\": {                   \"status\": \"SCREENED\",                   \"totalMatches\": 0,                   \"reviewRequired\": 0,                   \"unresolved\": 0               },               \"PASSPORT_CHECK\": {                   \"isReviewRequired\": false               }           }       },       {           \"caseSystemId\": \"Case System ID 3\",           \"requestFromScreenedDate\": \"2019-10-24T11:40:21.517Z\",           \"lastScreenedDate\": \"2019-12-20T08:25:32.146Z\",           \"providerSummaries\": {               \"WATCHLIST\": {                   \"status\": \"SCREENED\",                   \"totalMatches\": 625,                   \"reviewRequired\": 0,                   \"unresolved\": 618               },               \"MEDIA_CHECK\": {                   \"status\": \"SCREENED\",                   \"isReviewRequired\":               }           }       }   ] ``` 

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details)
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format
  - `content_type` (String.t): The media type of the request (e.g., 'application/json')
  - `content_length` (integer()): The length of the request body in octets (8-bit bytes)
  - `case_screening_status` (ScreeningStatusRequestCollection): Allows to specify cases and their screening dates that are using to define the screening status.
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, [%ScreeningStatusResponse{}, ...]}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec screening_status(Tesla.Env.client, String.t, String.t, String.t, integer(), RefinitivWorldCheckOneAPI.Model.ScreeningStatusRequestCollection.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.ScreeningStatusResponse.t)} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:error, Tesla.Env.t}
  def screening_status(connection, authorization, date, content_type, content_length, case_screening_status, _opts \\ []) do
    request =
      %{}
      |> method(:post)
      |> url("/cases/screeningStatus")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> add_param(:headers, :"Content-Type", content_type)
      |> add_param(:headers, :"Content-Length", content_length)
      |> add_param(:body, :body, case_screening_status)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, [%RefinitivWorldCheckOneAPI.Model.ScreeningStatusResponse{}]},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  User activity monitoring. Subsequent request.
  Continue loading result sets by cursor ID retrieved from POST/cases/summaries. 

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details)
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format
  - `content_type` (String.t): The media type of the request (e.g., 'application/json')
  - `content_length` (integer()): The length of the request body in octets (8-bit bytes)
  - `cursor` (Cursor): Request to continue cases retrieval.
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, RefinitivWorldCheckOneAPI.Model.CaseSearchResultResponse.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec scroll_case_summaries(Tesla.Env.client, String.t, String.t, String.t, integer(), RefinitivWorldCheckOneAPI.Model.Cursor.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:ok, RefinitivWorldCheckOneAPI.Model.CaseSearchResultResponse.t} | {:error, Tesla.Env.t}
  def scroll_case_summaries(connection, authorization, date, content_type, content_length, cursor, _opts \\ []) do
    request =
      %{}
      |> method(:post)
      |> url("/cases/summaries/cursor")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> add_param(:headers, :"Content-Type", content_type)
      |> add_param(:headers, :"Content-Length", content_length)
      |> add_param(:body, :body, cursor)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, %RefinitivWorldCheckOneAPI.Model.CaseSearchResultResponse{}},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  Bulk Update Ongoing Screening States
  Bulk Update Ongoing Screening (OGS) States of cases with provided `caseSystemIds` and `ProviderType`s specified in  `caseScreeningState`. Ongoing screening can be performed for MEDIA_CHECK and WATCHLIST provider types. The user must be active and have CASE_OGS permissions.  In response, the user receives a summary (`\"statuses\"`) of the World-Check/Media-Check Ongoing Screening operation for each case.  *Example HTTP response* below, shows the following summary:    1. Watchlist Ongoing Screening successfully enabled for the first case with `\"caseSystemId1\"`.   2. Media Check Ongoing Screening successfully disabled for the second case with `\"caseSystemId2\"`.   3. World-Check/Media-Check Ongoing Screening operation can not be performed for the third case with `\"caseSystemId3\"` because it does not meet the validation criteria;   `\"error\"` and `\"cause\"` fields contain detailed information on the error. 

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details)
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format
  - `content_type` (String.t): The media type of the request (e.g., 'application/json')
  - `content_length` (integer()): The length of the request body in octets (8-bit bytes)
  - `case_bulk_ongoing_screening_request` (CaseBulkOngoingScreeningRequest): A request on Bulk Update Ongoing Screening States
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, RefinitivWorldCheckOneAPI.Model.CaseBulkResponse.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec toggle_ongoing_screening_by_provider_types(Tesla.Env.client, String.t, String.t, String.t, integer(), RefinitivWorldCheckOneAPI.Model.CaseBulkOngoingScreeningRequest.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:ok, RefinitivWorldCheckOneAPI.Model.CaseBulkResponse.t} | {:error, Tesla.Env.t}
  def toggle_ongoing_screening_by_provider_types(connection, authorization, date, content_type, content_length, case_bulk_ongoing_screening_request, _opts \\ []) do
    request =
      %{}
      |> method(:post)
      |> url("/cases/bulk/ongoingScreening")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> add_param(:headers, :"Content-Type", content_type)
      |> add_param(:headers, :"Content-Length", content_length)
      |> add_param(:body, :body, case_bulk_ongoing_screening_request)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, %RefinitivWorldCheckOneAPI.Model.CaseBulkResponse{}},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  Unarchive a Case
  Unarchive the Case identified by the given caseSystemId. The user must be active and have the archive permission. 

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details)
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format
  - `case_system_id` (String.t): System generated ID for the Case
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, nil}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec unarchive(Tesla.Env.client, String.t, String.t, String.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:error, Tesla.Env.t}
  def unarchive(connection, authorization, date, case_system_id, _opts \\ []) do
    request =
      %{}
      |> method(:delete)
      |> url("/cases/#{case_system_id}/archive")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {204, false},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  Unassign a Case.
  Once you have assigned the case to the User, you can now unassign the same case.

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details)
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format
  - `case_system_id` (String.t): System generated ID for the Case
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, nil}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec unassign_case(Tesla.Env.client, String.t, String.t, String.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:error, Tesla.Env.t}
  def unassign_case(connection, authorization, date, case_system_id, _opts \\ []) do
    request =
      %{}
      |> method(:delete)
      |> url("/cases/#{case_system_id}/assignee")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {204, false},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  Bulk Move Cases Between Groups
  Bulk Move Cases identified by the given `caseSystemIds` to the `Group` identified by the given `groupId`. The user must be active and have move cases between groups permissions. The client must have move cases functionality enabled. The current Group and the destination Group should contain identical custom fields. Cases can not be moved to ZFS group.  In response, the user receives a summary (`\"statuses\"`) of the moving cases operation for each case.  *Example HTTP response* below, shows the following summary:    1. The first case with `\"caseSystemId1\"` has been moved successfully.   2. The second case with `\"caseSystemId2\"` has been moved successfully.   3. The third case with `\"caseSystemId3\"` has not been moved because it does not meet the validation criteria;   `\"error\"` and `\"cause\"` fields contain detailed information on the error. 

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details)
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format
  - `content_type` (String.t): The media type of the request (e.g., 'application/json')
  - `content_length` (integer()): The length of the request body in octets (8-bit bytes)
  - `case_bulk_move_request` (CaseBulkMoveRequest): A request on Bulk Move Cases
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, RefinitivWorldCheckOneAPI.Model.CaseBulkResponse.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec update_cases_owner(Tesla.Env.client, String.t, String.t, String.t, integer(), RefinitivWorldCheckOneAPI.Model.CaseBulkMoveRequest.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:ok, RefinitivWorldCheckOneAPI.Model.CaseBulkResponse.t} | {:error, Tesla.Env.t}
  def update_cases_owner(connection, authorization, date, content_type, content_length, case_bulk_move_request, _opts \\ []) do
    request =
      %{}
      |> method(:post)
      |> url("/cases/bulk/move")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> add_param(:headers, :"Content-Type", content_type)
      |> add_param(:headers, :"Content-Length", content_length)
      |> add_param(:body, :body, case_bulk_move_request)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, %RefinitivWorldCheckOneAPI.Model.CaseBulkResponse{}},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end

  @doc """
  Update an existing Case by its caseSystemId
  Updates an existing Case identified by the given caseSystemId. When the case is updated, all the non-empty fields for the case are required to be sent, including the updated field(s). Non-empty fields that are not sent when calling this endpoint will be overwritten as null. For example, if the date of birth for a case need to be updated, existing fields such as nationality, etc. should contain the original values, otherwise it will be updated as null. That is, all the other fields should be included in the body with their existing data. This applies to Custom Fields as well.  **Info about available secondary fields can be found [here](#tag/groups/operation/getCaseTemplateForGroup).** 

  ### Parameters

  - `connection` (RefinitivWorldCheckOneAPI.Connection): Connection to server
  - `authorization` (String.t): The authorization credentials including 'keyId', 'algorithm', 'headers', 'signature' (see 'Security and Authentication details' documentation section for more details)
  - `date` (String.t): The date and time at which the message was originated in 'RFC 1123' format
  - `content_type` (String.t): The media type of the request (e.g., 'application/json')
  - `content_length` (integer()): The length of the request body in octets (8-bit bytes)
  - `case_system_id` (String.t): System generated ID for the Case
  - `update_case` (UpdateCase): Update Case
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, RefinitivWorldCheckOneAPI.Model.Case.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec update_existing_case(Tesla.Env.client, String.t, String.t, String.t, integer(), String.t, RefinitivWorldCheckOneAPI.Model.UpdateCase.t, keyword()) :: {:ok, nil} | {:ok, list(RefinitivWorldCheckOneAPI.Model.Error.t)} | {:ok, RefinitivWorldCheckOneAPI.Model.Case.t} | {:error, Tesla.Env.t}
  def update_existing_case(connection, authorization, date, content_type, content_length, case_system_id, update_case, _opts \\ []) do
    request =
      %{}
      |> method(:put)
      |> url("/cases/#{case_system_id}")
      |> add_param(:headers, :Authorization, authorization)
      |> add_param(:headers, :Date, date)
      |> add_param(:headers, :"Content-Type", content_type)
      |> add_param(:headers, :"Content-Length", content_length)
      |> add_param(:body, :body, update_case)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, %RefinitivWorldCheckOneAPI.Model.Case{}},
      {400, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {401, false},
      {404, [%RefinitivWorldCheckOneAPI.Model.Error{}]},
      {415, false},
      {429, false},
      {500, [%RefinitivWorldCheckOneAPI.Model.Error{}]}
    ])
  end
end
